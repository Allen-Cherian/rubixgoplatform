// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.20.1
// source: rubix-native.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	RubixService_CreateDIDChallenge_FullMethodName      = "/protos.RubixService/CreateDIDChallenge"
	RubixService_CreateDID_FullMethodName               = "/protos.RubixService/CreateDID"
	RubixService_InitiateTransaction_FullMethodName     = "/protos.RubixService/InitiateTransaction"
	RubixService_StreamIncomingTxn_FullMethodName       = "/protos.RubixService/StreamIncomingTxn"
	RubixService_SignResponse_FullMethodName            = "/protos.RubixService/SignResponse"
	RubixService_GenerateRbt_FullMethodName             = "/protos.RubixService/GenerateRbt"
	RubixService_GetBalance_FullMethodName              = "/protos.RubixService/GetBalance"
	RubixService_GetAccessTokenChallenge_FullMethodName = "/protos.RubixService/GetAccessTokenChallenge"
	RubixService_GenerateAccessToken_FullMethodName     = "/protos.RubixService/GenerateAccessToken"
	RubixService_GetTransactionHistory_FullMethodName   = "/protos.RubixService/GetTransactionHistory"
)

// RubixServiceClient is the client API for RubixService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RubixServiceClient interface {
	CreateDIDChallenge(ctx context.Context, in *ChallengeReq, opts ...grpc.CallOption) (*ChallengeString, error)
	CreateDID(ctx context.Context, in *CreateDIDReq, opts ...grpc.CallOption) (*CreateDIDRes, error)
	InitiateTransaction(ctx context.Context, in *RequestTransactionPayloadReq, opts ...grpc.CallOption) (*RequestTransactionPayloadRes, error)
	StreamIncomingTxn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (RubixService_StreamIncomingTxnClient, error)
	SignResponse(ctx context.Context, in *HashSigned, opts ...grpc.CallOption) (*Status, error)
	GenerateRbt(ctx context.Context, in *GenerateReq, opts ...grpc.CallOption) (*RequestTransactionPayloadRes, error)
	GetBalance(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetBalanceRes, error)
	GetAccessTokenChallenge(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeString, error)
	GenerateAccessToken(ctx context.Context, in *SignedPayload, opts ...grpc.CallOption) (*Token, error)
	GetTransactionHistory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TransactionHistory, error)
}

type rubixServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRubixServiceClient(cc grpc.ClientConnInterface) RubixServiceClient {
	return &rubixServiceClient{cc}
}

func (c *rubixServiceClient) CreateDIDChallenge(ctx context.Context, in *ChallengeReq, opts ...grpc.CallOption) (*ChallengeString, error) {
	out := new(ChallengeString)
	err := c.cc.Invoke(ctx, RubixService_CreateDIDChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) CreateDID(ctx context.Context, in *CreateDIDReq, opts ...grpc.CallOption) (*CreateDIDRes, error) {
	out := new(CreateDIDRes)
	err := c.cc.Invoke(ctx, RubixService_CreateDID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) InitiateTransaction(ctx context.Context, in *RequestTransactionPayloadReq, opts ...grpc.CallOption) (*RequestTransactionPayloadRes, error) {
	out := new(RequestTransactionPayloadRes)
	err := c.cc.Invoke(ctx, RubixService_InitiateTransaction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) StreamIncomingTxn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (RubixService_StreamIncomingTxnClient, error) {
	stream, err := c.cc.NewStream(ctx, &RubixService_ServiceDesc.Streams[0], RubixService_StreamIncomingTxn_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &rubixServiceStreamIncomingTxnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RubixService_StreamIncomingTxnClient interface {
	Recv() (*IncomingTxnDetails, error)
	grpc.ClientStream
}

type rubixServiceStreamIncomingTxnClient struct {
	grpc.ClientStream
}

func (x *rubixServiceStreamIncomingTxnClient) Recv() (*IncomingTxnDetails, error) {
	m := new(IncomingTxnDetails)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rubixServiceClient) SignResponse(ctx context.Context, in *HashSigned, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, RubixService_SignResponse_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) GenerateRbt(ctx context.Context, in *GenerateReq, opts ...grpc.CallOption) (*RequestTransactionPayloadRes, error) {
	out := new(RequestTransactionPayloadRes)
	err := c.cc.Invoke(ctx, RubixService_GenerateRbt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) GetBalance(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetBalanceRes, error) {
	out := new(GetBalanceRes)
	err := c.cc.Invoke(ctx, RubixService_GetBalance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) GetAccessTokenChallenge(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeString, error) {
	out := new(ChallengeString)
	err := c.cc.Invoke(ctx, RubixService_GetAccessTokenChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) GenerateAccessToken(ctx context.Context, in *SignedPayload, opts ...grpc.CallOption) (*Token, error) {
	out := new(Token)
	err := c.cc.Invoke(ctx, RubixService_GenerateAccessToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rubixServiceClient) GetTransactionHistory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TransactionHistory, error) {
	out := new(TransactionHistory)
	err := c.cc.Invoke(ctx, RubixService_GetTransactionHistory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RubixServiceServer is the server API for RubixService service.
// All implementations must embed UnimplementedRubixServiceServer
// for forward compatibility
type RubixServiceServer interface {
	CreateDIDChallenge(context.Context, *ChallengeReq) (*ChallengeString, error)
	CreateDID(context.Context, *CreateDIDReq) (*CreateDIDRes, error)
	InitiateTransaction(context.Context, *RequestTransactionPayloadReq) (*RequestTransactionPayloadRes, error)
	StreamIncomingTxn(*emptypb.Empty, RubixService_StreamIncomingTxnServer) error
	SignResponse(context.Context, *HashSigned) (*Status, error)
	GenerateRbt(context.Context, *GenerateReq) (*RequestTransactionPayloadRes, error)
	GetBalance(context.Context, *emptypb.Empty) (*GetBalanceRes, error)
	GetAccessTokenChallenge(context.Context, *emptypb.Empty) (*ChallengeString, error)
	GenerateAccessToken(context.Context, *SignedPayload) (*Token, error)
	GetTransactionHistory(context.Context, *emptypb.Empty) (*TransactionHistory, error)
	mustEmbedUnimplementedRubixServiceServer()
}

// UnimplementedRubixServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRubixServiceServer struct {
}

func (UnimplementedRubixServiceServer) CreateDIDChallenge(context.Context, *ChallengeReq) (*ChallengeString, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDIDChallenge not implemented")
}
func (UnimplementedRubixServiceServer) CreateDID(context.Context, *CreateDIDReq) (*CreateDIDRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDID not implemented")
}
func (UnimplementedRubixServiceServer) InitiateTransaction(context.Context, *RequestTransactionPayloadReq) (*RequestTransactionPayloadRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateTransaction not implemented")
}
func (UnimplementedRubixServiceServer) StreamIncomingTxn(*emptypb.Empty, RubixService_StreamIncomingTxnServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamIncomingTxn not implemented")
}
func (UnimplementedRubixServiceServer) SignResponse(context.Context, *HashSigned) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignResponse not implemented")
}
func (UnimplementedRubixServiceServer) GenerateRbt(context.Context, *GenerateReq) (*RequestTransactionPayloadRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRbt not implemented")
}
func (UnimplementedRubixServiceServer) GetBalance(context.Context, *emptypb.Empty) (*GetBalanceRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedRubixServiceServer) GetAccessTokenChallenge(context.Context, *emptypb.Empty) (*ChallengeString, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessTokenChallenge not implemented")
}
func (UnimplementedRubixServiceServer) GenerateAccessToken(context.Context, *SignedPayload) (*Token, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateAccessToken not implemented")
}
func (UnimplementedRubixServiceServer) GetTransactionHistory(context.Context, *emptypb.Empty) (*TransactionHistory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionHistory not implemented")
}
func (UnimplementedRubixServiceServer) mustEmbedUnimplementedRubixServiceServer() {}

// UnsafeRubixServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RubixServiceServer will
// result in compilation errors.
type UnsafeRubixServiceServer interface {
	mustEmbedUnimplementedRubixServiceServer()
}

func RegisterRubixServiceServer(s grpc.ServiceRegistrar, srv RubixServiceServer) {
	s.RegisterService(&RubixService_ServiceDesc, srv)
}

func _RubixService_CreateDIDChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChallengeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).CreateDIDChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_CreateDIDChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).CreateDIDChallenge(ctx, req.(*ChallengeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_CreateDID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).CreateDID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_CreateDID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).CreateDID(ctx, req.(*CreateDIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_InitiateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTransactionPayloadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).InitiateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_InitiateTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).InitiateTransaction(ctx, req.(*RequestTransactionPayloadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_StreamIncomingTxn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RubixServiceServer).StreamIncomingTxn(m, &rubixServiceStreamIncomingTxnServer{stream})
}

type RubixService_StreamIncomingTxnServer interface {
	Send(*IncomingTxnDetails) error
	grpc.ServerStream
}

type rubixServiceStreamIncomingTxnServer struct {
	grpc.ServerStream
}

func (x *rubixServiceStreamIncomingTxnServer) Send(m *IncomingTxnDetails) error {
	return x.ServerStream.SendMsg(m)
}

func _RubixService_SignResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashSigned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).SignResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_SignResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).SignResponse(ctx, req.(*HashSigned))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_GenerateRbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).GenerateRbt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_GenerateRbt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).GenerateRbt(ctx, req.(*GenerateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_GetBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).GetBalance(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_GetAccessTokenChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).GetAccessTokenChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_GetAccessTokenChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).GetAccessTokenChallenge(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_GenerateAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).GenerateAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_GenerateAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).GenerateAccessToken(ctx, req.(*SignedPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _RubixService_GetTransactionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RubixServiceServer).GetTransactionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RubixService_GetTransactionHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RubixServiceServer).GetTransactionHistory(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// RubixService_ServiceDesc is the grpc.ServiceDesc for RubixService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RubixService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protos.RubixService",
	HandlerType: (*RubixServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDIDChallenge",
			Handler:    _RubixService_CreateDIDChallenge_Handler,
		},
		{
			MethodName: "CreateDID",
			Handler:    _RubixService_CreateDID_Handler,
		},
		{
			MethodName: "InitiateTransaction",
			Handler:    _RubixService_InitiateTransaction_Handler,
		},
		{
			MethodName: "SignResponse",
			Handler:    _RubixService_SignResponse_Handler,
		},
		{
			MethodName: "GenerateRbt",
			Handler:    _RubixService_GenerateRbt_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _RubixService_GetBalance_Handler,
		},
		{
			MethodName: "GetAccessTokenChallenge",
			Handler:    _RubixService_GetAccessTokenChallenge_Handler,
		},
		{
			MethodName: "GenerateAccessToken",
			Handler:    _RubixService_GenerateAccessToken_Handler,
		},
		{
			MethodName: "GetTransactionHistory",
			Handler:    _RubixService_GetTransactionHistory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamIncomingTxn",
			Handler:       _RubixService_StreamIncomingTxn_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rubix-native.proto",
}
